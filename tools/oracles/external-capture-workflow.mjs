#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

import { buildCaptureProgress } from './lib/capture-progress.mjs';
import {
  buildCaptureManifestFromOracleDataset,
  buildMissionOracleDatasetFromRows,
  canonicalizeReferenceRowsObjectAndSideIds,
  canonicalizeReferenceRowsObjectIds,
  canonicalizeReferenceRowsSideIds,
  mergeRows,
  readJsonLines,
  validateReferenceRows,
  writeJsonFile,
} from './lib/reference-jsonl.mjs';
import {
  compareMissionOracleDatasets,
  validateMissionOracleDataset,
} from './lib/reference-compare.mjs';
import {
  compareReferenceSignalRows,
  rowsFromMissionOracleDataset,
} from './lib/reference-jsonl-compare.mjs';

function argValue(flag, fallback = null) {
  const idx = process.argv.indexOf(flag);
  if (idx === -1 || idx + 1 >= process.argv.length) return fallback;
  return process.argv[idx + 1];
}

function hasFlag(flag) {
  return process.argv.includes(flag);
}

function intArg(flag, fallback) {
  const raw = argValue(flag, null);
  if (raw === null) return fallback;
  const parsed = Number(raw);
  if (!Number.isFinite(parsed)) return fallback;
  return Math.max(1, Math.floor(parsed));
}

function usage() {
  console.log(
    'Usage: node tools/oracles/external-capture-workflow.mjs <command> [options]\n' +
    '\n' +
    'Commands:\n' +
    '  prepare   Build capture manifest/header and emit tranche plan report.\n' +
    '  status    Recompute capture progress + tranche plan from current capture rows.\n' +
    '  finalize  Validate/normalize capture and run strict data parity checks.\n' +
    '\n' +
    'Common options:\n' +
    '  --oracle <tok_mission_oracle.v1.json>\n' +
    '  --manifest <tok_capture_manifest.v1.json>\n' +
    '  --capture <tok_capture_merged.jsonl>\n' +
    '  --scripts all|fast\n' +
    '  --plan-out <reference_capture_plan.report.json>\n' +
    '  --batch-missions <N>\n' +
    '\n' +
    'Finalize options:\n' +
    '  --reference <tok_mission_oracle.reference.v1.json>\n' +
    '  --finalize-report <reference_finalize.report.json>\n' +
    '  --canonicalize-object-ids\n' +
    '  --canonicalize-side-ids\n' +
    '  --strict',
  );
}

function readJson(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function cString(str) {
  return `"${String(str)
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')}"`;
}

function writeHookHeaderFromManifest(manifest, outputFile) {
  if (!Array.isArray(manifest.missions)) {
    throw new Error('Manifest must contain missions[]');
  }

  const lines = [];
  lines.push('// Auto-generated by tools/oracles/external-capture-workflow.mjs');
  lines.push('// Do not edit by hand.');
  lines.push('#pragma once');
  lines.push('');
  lines.push('typedef struct TokCaptureMissionEntry {');
  lines.push('  const char* script_id;');
  lines.push('  int max_tick;');
  lines.push('  int frame_count;');
  lines.push('  int checkpoint_count;');
  lines.push('  const int* checkpoints;');
  lines.push('} TokCaptureMissionEntry;');
  lines.push('');

  for (let i = 0; i < manifest.missions.length; i++) {
    const mission = manifest.missions[i];
    const checkpoints = Array.isArray(mission.checkpointTicks) ? mission.checkpointTicks : [];
    const symbol = `TOK_CAPTURE_CHECKPOINTS_${String(i).padStart(3, '0')}`;
    lines.push(`static const int ${symbol}[] = { ${checkpoints.join(', ')} }; // ${mission.scriptId}`);
  }

  lines.push('');
  lines.push('static const TokCaptureMissionEntry TOK_CAPTURE_MISSIONS[] = {');
  for (let i = 0; i < manifest.missions.length; i++) {
    const mission = manifest.missions[i];
    const symbol = `TOK_CAPTURE_CHECKPOINTS_${String(i).padStart(3, '0')}`;
    const frameCount = Number.isFinite(mission.frameCount) ? mission.frameCount : (mission.maxTick + 1);
    const checkpointCount = Array.isArray(mission.checkpointTicks) ? mission.checkpointTicks.length : 0;
    lines.push(
      `  { ${cString(mission.scriptId)}, ${mission.maxTick}, ${frameCount}, ${checkpointCount}, ${symbol} },`,
    );
  }
  lines.push('};');
  lines.push('');
  lines.push(`static const int TOK_CAPTURE_MISSION_COUNT = ${manifest.missions.length};`);
  lines.push('');

  fs.mkdirSync(path.dirname(outputFile), { recursive: true });
  fs.writeFileSync(outputFile, `${lines.join('\n')}\n`, 'utf8');
}

function buildTranchePlan(progress, batchMissions) {
  const incomplete = [...progress.missions]
    .filter((m) => !m.complete)
    .sort((a, b) => a.completion - b.completion || a.scriptId.localeCompare(b.scriptId));

  const tranches = [];
  for (let i = 0; i < incomplete.length; i += batchMissions) {
    const slice = incomplete.slice(i, i + batchMissions);
    const index = Math.floor(i / batchMissions) + 1;
    tranches.push({
      tranche: index,
      missionCount: slice.length,
      missions: slice.map((m) => ({
        scriptId: m.scriptId,
        capturedCheckpoints: m.capturedCheckpoints,
        requiredCheckpoints: m.requiredCheckpoints,
        completion: m.completion,
        missingTicks: m.missingTicks,
      })),
    });
  }

  return {
    nextTranche: tranches[0] ?? null,
    tranches,
  };
}

function readRowsIfExists(filePath) {
  if (!fs.existsSync(filePath)) return [];
  return readJsonLines(filePath);
}

function normalizeRowsForCompare(rows, options) {
  const canonicalizeObjectIds = options.canonicalizeObjectIds === true;
  const canonicalizeSideIds = options.canonicalizeSideIds === true;

  if (canonicalizeObjectIds && canonicalizeSideIds) {
    return canonicalizeReferenceRowsObjectAndSideIds(rows);
  }
  if (canonicalizeObjectIds) {
    return canonicalizeReferenceRowsObjectIds(rows);
  }
  if (canonicalizeSideIds) {
    return canonicalizeReferenceRowsSideIds(rows);
  }
  return rows;
}

function selectScriptIds(oracle, scripts) {
  if (scripts === 'fast') {
    return (oracle.fastScripts ?? []).filter((scriptId) => oracle.missions?.[scriptId] !== undefined);
  }
  return Object.keys(oracle.missions ?? {}).sort((a, b) => a.localeCompare(b));
}

function subsetOracleDataset(dataset, scriptIds) {
  const set = new Set(scriptIds);
  const missions = Object.fromEntries(
    Object.entries(dataset.missions ?? {})
      .filter(([scriptId]) => set.has(scriptId)),
  );
  return {
    schemaVersion: dataset.schemaVersion,
    generator: dataset.generator,
    generatedAt: dataset.generatedAt,
    seed: dataset.seed,
    defaultMaxTick: dataset.defaultMaxTick,
    headerMaxTick: dataset.headerMaxTick,
    checkpointStride: dataset.checkpointStride,
    fastScripts: (dataset.fastScripts ?? []).filter((scriptId) => set.has(scriptId)),
    missions,
  };
}

function ensureScriptsValue(scripts) {
  if (scripts !== 'all' && scripts !== 'fast') {
    throw new Error(`--scripts must be all|fast, got: ${scripts}`);
  }
}

const repoRoot = process.cwd();
const command = process.argv[2];

if (!command || command === '--help' || command === '-h') {
  usage();
  process.exit(0);
}

const oracleFile = argValue(
  '--oracle',
  path.join(repoRoot, 'tests/campaign/tok/oracles/tok_mission_oracle.v1.json'),
);
const manifestFile = argValue(
  '--manifest',
  path.join(repoRoot, 'tools/oracles/reference/tok_capture_manifest.v1.json'),
);
const headerFile = argValue(
  '--header',
  path.join(repoRoot, 'tools/oracles/reference/tok_capture_manifest.generated.h'),
);
const captureFile = argValue(
  '--capture',
  path.join(repoRoot, 'tools/oracles/reference/tok_capture_merged.jsonl'),
);
const referenceFile = argValue(
  '--reference',
  path.join(repoRoot, 'tools/oracles/reference/tok_mission_oracle.reference.v1.json'),
);
const planOut = argValue(
  '--plan-out',
  path.join(repoRoot, 'artifacts/oracle-diffs/reference_capture_plan.report.json'),
);
const finalizeReport = argValue(
  '--finalize-report',
  path.join(repoRoot, 'artifacts/oracle-diffs/reference_finalize.report.json'),
);
const scripts = argValue('--scripts', 'all');
const batchMissions = intArg('--batch-missions', 12);
const strict = hasFlag('--strict');
const canonicalizeObjectIds = hasFlag('--canonicalize-object-ids');
const canonicalizeSideIds = hasFlag('--canonicalize-side-ids');

try {
  if (command === 'prepare') {
    ensureScriptsValue(scripts);
    if (!fs.existsSync(oracleFile)) {
      throw new Error(`Oracle file not found: ${oracleFile}`);
    }

    const oracle = readJson(oracleFile);
    const validation = validateMissionOracleDataset(oracle, 'oracle');
    if (!validation.valid) {
      throw new Error(`Oracle schema validation failed (${validation.errors.length} errors)`);
    }

    const manifest = buildCaptureManifestFromOracleDataset(oracle, { scripts });
    writeJsonFile(manifestFile, manifest);
    writeHookHeaderFromManifest(manifest, headerFile);

    const rows = readRowsIfExists(captureFile);
    const progress = buildCaptureProgress(rows, manifest);
    const plan = buildTranchePlan(progress, batchMissions);
    const report = {
      status: 'prepared',
      generatedAt: new Date().toISOString(),
      oracleFile,
      manifestFile,
      headerFile,
      captureFile,
      scripts,
      batchMissions,
      captureFileExists: fs.existsSync(captureFile),
      ...progress,
      ...plan,
    };
    writeJsonFile(planOut, report);

    console.log(`[workflow] prepared manifest (${manifest.missionCount} missions): ${manifestFile}`);
    console.log(`[workflow] generated hook header: ${headerFile}`);
    console.log(
      `[workflow] coverage missions=${progress.completeMissionCount}/${progress.missionCount} ` +
      `checkpoints=${progress.capturedCheckpoints}/${progress.requiredCheckpoints}`,
    );
    console.log(`[workflow] wrote tranche plan: ${planOut}`);
    process.exit(0);
  }

  if (command === 'status') {
    if (!fs.existsSync(manifestFile)) {
      throw new Error(`Manifest file not found: ${manifestFile}`);
    }
    const manifest = readJson(manifestFile);
    const rows = readRowsIfExists(captureFile);
    const progress = buildCaptureProgress(rows, manifest);
    const plan = buildTranchePlan(progress, batchMissions);
    const report = {
      status: progress.completeMissionCount === progress.missionCount ? 'complete' : 'in-progress',
      generatedAt: new Date().toISOString(),
      manifestFile,
      captureFile,
      batchMissions,
      strict,
      captureFileExists: fs.existsSync(captureFile),
      ...progress,
      ...plan,
    };
    writeJsonFile(planOut, report);

    console.log(
      `[workflow] missions ${progress.completeMissionCount}/${progress.missionCount} ` +
      `(${progress.missionCoverage.toFixed(4)}), checkpoints ${progress.capturedCheckpoints}/${progress.requiredCheckpoints} ` +
      `(${progress.checkpointCoverage.toFixed(4)})`,
    );
    if (plan.nextTranche) {
      console.log(
        `[workflow] next tranche #${plan.nextTranche.tranche}: ` +
        `${plan.nextTranche.missionCount} missions`,
      );
    } else {
      console.log('[workflow] no remaining capture tranches');
    }
    console.log(`[workflow] wrote tranche plan: ${planOut}`);

    if (strict && (progress.completeMissionCount !== progress.missionCount || progress.unexpectedMissions.length > 0)) {
      process.exit(1);
    }
    process.exit(0);
  }

  if (command === 'finalize') {
    ensureScriptsValue(scripts);
    if (!fs.existsSync(oracleFile)) {
      throw new Error(`Oracle file not found: ${oracleFile}`);
    }
    if (!fs.existsSync(captureFile)) {
      throw new Error(`Capture file not found: ${captureFile}`);
    }

    const oracle = readJson(oracleFile);
    const oracleValidation = validateMissionOracleDataset(oracle, 'oracle');
    if (!oracleValidation.valid) {
      throw new Error(`Oracle schema validation failed (${oracleValidation.errors.length} errors)`);
    }

    const manifest = fs.existsSync(manifestFile)
      ? readJson(manifestFile)
      : buildCaptureManifestFromOracleDataset(oracle, { scripts: 'all' });
    if (!fs.existsSync(manifestFile)) {
      writeJsonFile(manifestFile, manifest);
    }
    const manifestForProgress = buildCaptureManifestFromOracleDataset(oracle, { scripts });

    const rawRows = readJsonLines(captureFile);
    const merged = mergeRows(rawRows, {
      prefer: 'last',
      strictConflicts: false,
    });

    const selectedScriptIds = selectScriptIds(oracle, scripts);
    const expectedMissionMax = Object.fromEntries(
      selectedScriptIds.map((scriptId) => [scriptId, oracle.missions[scriptId].maxTick]),
    );
    const validation = validateReferenceRows(merged.rows, {
      expectedMissionMax,
      requireAllMissions: true,
      requireExpectedMaxTick: true,
      requireTickZero: true,
    });
    const progress = buildCaptureProgress(merged.rows, manifestForProgress);
    const manifestComplete = progress.missions.every((m) => m.complete);

    const normalized = buildMissionOracleDatasetFromRows(merged.rows, {
      checkpointStride: oracle.checkpointStride,
      seed: oracle.seed,
      defaultMaxTick: oracle.defaultMaxTick,
      headerMaxTick: oracle.headerMaxTick,
      fastScripts: oracle.fastScripts,
      generator: 'external-reference-normalizer-v2',
    });
    writeJsonFile(referenceFile, normalized);

    const selectedOracle = subsetOracleDataset(oracle, selectedScriptIds);
    const selectedNormalized = subsetOracleDataset(normalized, selectedScriptIds);
    const datasetCompare = compareMissionOracleDatasets(selectedNormalized, selectedOracle, {
      requireAllMissions: true,
      minCoverage: 1,
    });

    const compareRows = normalizeRowsForCompare(merged.rows, {
      canonicalizeObjectIds,
      canonicalizeSideIds,
    });
    const expectedRows = rowsFromMissionOracleDataset(oracle, {
      scripts,
      includeFinal: true,
    });
    const rowCompare = compareReferenceSignalRows(compareRows, expectedRows, {
      requireAllExpectedRows: true,
      minCoverage: 1,
    });

    const finalize = {
      status: 'ok',
      generatedAt: new Date().toISOString(),
      oracleFile,
      manifestFile,
      captureFile,
      referenceFile,
      strict,
      scripts,
      canonicalizeObjectIds,
      canonicalizeSideIds,
      inputRows: rawRows.length,
      mergedRows: merged.rows.length,
      mergeConflicts: merged.conflicts.length,
      validation: {
        ok: validation.ok,
        errors: validation.errors,
        warnings: validation.warnings,
        coverage: validation.coverage,
        missionCount: validation.missionCount,
      },
      manifestProgress: {
        missionCoverage: progress.missionCoverage,
        checkpointCoverage: progress.checkpointCoverage,
        completeMissionCount: progress.completeMissionCount,
        missionCount: progress.missionCount,
        complete: manifestComplete,
      },
      selectedScriptIds,
      datasetCompare: {
        diff: datasetCompare.diff,
        coverage: datasetCompare.coverage,
        missingInInternal: datasetCompare.missingInInternal,
        missingInReference: datasetCompare.missingInReference,
      },
      rowCompare,
    };

    let failed = false;
    const failureReasons = [];
    if (!validation.ok) {
      failed = true;
      failureReasons.push('reference-jsonl-validation');
    }
    if (!manifestComplete) {
      failed = true;
      failureReasons.push('manifest-checkpoint-coverage');
    }
    if (datasetCompare.diff) {
      failed = true;
      failureReasons.push('dataset-compare');
    }
    if (rowCompare.diff) {
      failed = true;
      failureReasons.push('row-compare');
    }

    finalize.status = failed ? 'failed' : 'ok';
    finalize.failureReasons = failureReasons;
    writeJsonFile(finalizeReport, finalize);

    console.log(
      `[workflow] finalize validation=${validation.ok} manifestComplete=${manifestComplete} ` +
      `datasetDiff=${datasetCompare.diff ? 'yes' : 'no'} rowDiff=${rowCompare.diff ? 'yes' : 'no'}`,
    );
    console.log(`[workflow] wrote normalized reference: ${referenceFile}`);
    console.log(`[workflow] wrote finalize report: ${finalizeReport}`);

    if (failed && strict) {
      process.exit(1);
    }
    process.exit(0);
  }

  usage();
  process.exit(2);
} catch (err) {
  console.error(`[workflow] ${String(err)}`);
  process.exit(2);
}
